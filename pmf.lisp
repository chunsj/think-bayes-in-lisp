(in-package :think-bayes)

(defclass pmf (distribution) ())

(defmethod print-object ((pmf pmf) stream) (call-next-method))

(defun pmf (&key (name "") (values nil))
  (create-distribution 'pmf :name name :values values))

(defgeneric probability (pmf x &optional default))
(defgeneric probabilities (pmf xs))
(defgeneric make-cdf (pmf &key name))
(defgeneric probability-of-> (pmf x))
(defgeneric probability-of-< (pmf x))
(defgeneric probability-of-= (pmf x))
(defgeneric probability-of->= (pmf x))
(defgeneric probability-of-<= (pmf x))
(defgeneric probability-of-not= (pmf x))
(defgeneric variable-random (pmf))
(defgeneric variable-mean (pmf))
(defgeneric variable-variance (pmf &optional mu))
(defgeneric maximum-likelihood (pmf))
(defgeneric credible-interval (pmf &optional percentage))

(defmethod probability ((pmf pmf) x &optional default) ($ pmf x default))
(defmethod probabilities ((pmf pmf) xs) (loop :for x :in xs :collect (probability pmf x)))
(defmethod make-cdf ((pmf pmf) &key name) (make-cdf-from pmf :name name))

(defmethod probability-of-> ((pmf pmf) (x number))
  (loop :for pair :in (variable-pairs pmf) :when (> (car pair) x) :sum (cdr pair)))
(defmethod probability-of-> ((pmf pmf) (o distribution))
  (let ((total 0.0))
    (do-attributes pmf (lambda (v1 p1)
                         (do-attributes o (lambda (v2 p2)
                                            (when (> v1 v2)
                                              (incf total (* p1 p2)))))))
    total))

(defmethod probability-of-< ((pmf pmf) (x number))
  (loop :for pair :in (variable-pairs pmf) :when (< (car pair) x) :sum (cdr pair)))
(defmethod probability-of-< ((pmf pmf) (o distribution))
  (let ((total 0.0))
    (do-attributes pmf (lambda (v1 p1)
                         (do-attributes o (lambda (v2 p2)
                                            (when (< v1 v2)
                                              (incf total (* p1 p2)))))))
    total))

(defmethod probability-of-= ((pmf pmf) (x number)) (probability pmf x))
(defmethod probability-of-= ((pmf pmf) (o distribution))
  (let ((total 0.0))
    (do-attributes pmf (lambda (v1 p1)
                         (do-attributes o (lambda (v2 p2)
                                            (when (= v1 v2)
                                              (incf total (* p1 p2)))))))
    total))

(defmethod probability-of->= ((pmf pmf) x) (- 1.0 (probability-of-< pmf x)))
(defmethod probability-of-<= ((pmf pmf) x) (- 1.0 (probability-of-> pmf x)))
(defmethod probability-of-not= ((pmf pmf) x) (- 1.0 (probability-of-= pmf x)))

(defmethod normalize ((pmf pmf) &optional (fraction 1.0))
  (when (logarithmizedp pmf)
    (error "pmf is under a log transform"))
  (let ((total (attribute-total pmf)))
    (if (= total 0.0)
        (error "total probability is zero")
        (let ((f (/ (float fraction) total)))
          (do-attributes pmf (lambda (x v) (setf ($ pmf x) (* f v))))
          total))))

(defmethod variable-random ((pmf pmf))
  (when (= ($count pmf) 0) (error "pmf contains no value"))
  (let ((target (random 1.0))
        (total 0.0))
    (loop :for pair :in (variable-pairs pmf)
          :for x = (car pair)
          :for p = (cdr pair)
          :do (incf total p)
          :when (> total target)
            :return x)))

(defmethod variable-mean ((pmf pmf))
  (let ((mu 0.0))
    (loop :for pair :in (variable-pairs pmf)
          :for x = (car pair)
          :for p = (cdr pair)
          :do (incf mu (* p x)))
    mu))

(defmethod variable-variance ((pmf pmf) &optional mu)
  (let ((m (or mu (variable-mean pmf)))
        (var 0.0))
    (loop :for pair :in (variable-pairs pmf)
          :for x = (car pair)
          :for p = (cdr pair)
          :do (incf var (* p (expt (- x m) 2))))
    var))

(defmethod maximum-likelihood ((pmf pmf))
  (car (reduce (lambda (iv rv)
                 (if (> (cdr iv) (cdr rv)) iv rv))
               (variable-pairs pmf))))

(defmethod credible-interval ((pmf pmf) &optional (percentage 90))
  (let ((cdf (make-cdf pmf)))
    (credible-interval cdf percentage)))

(defmethod add ((pmf pmf) (o number))
  (let ((ni (make-instance 'pmf)))
    (do-attributes pmf (lambda (v1 p1)
                         (assign pmf (+ v1 o) p1)))
    ni))

(defmethod add ((pmf pmf) (o distribution))
  (let ((ni (make-instance 'pmf)))
    (do-attributes pmf (lambda (v1 p1)
                         (do-attributes o (lambda (v2 p2)
                                            (increase ni (+ v1 v2) (* p1 p2))))))
    ni))

(defmethod subtract ((pmf pmf) (o number))
  (let ((ni (make-instance 'pmf)))
    (do-attributes pmf (lambda (v1 p1)
                         (assign pmf (- v1 o) p1)))
    ni))

(defmethod subtract ((pmf pmf) (o distribution))
  (let ((ni (make-instance 'pmf)))
    (do-attributes pmf (lambda (v1 p1)
                         (do-attributes o (lambda (v2 p2)
                                            (increase ni (- v1 v2) (* p1 p2))))))
    ni))
